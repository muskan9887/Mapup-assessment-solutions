# -*- coding: utf-8 -*-
"""python_task2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HUuVnAAHE1V9JcNSBoEj02izwU95uYgj
"""

import pandas as pd

"""### Question 1"""

import networkx as nx

def calculate_distance_matrix(file_path):
    # Load the CSV file into a DataFrame
    df = pd.read_csv(file_path)

    # Create a graph using NetworkX
    G = nx.Graph()

    # Add edges with distances to the graph
    for index, row in df.iterrows():
        G.add_edge(row['id_start'], row['id_end'], distance=row['distance'])
        G.add_edge(row['id_end'], row['id_start'], distance=row['distance'])  # Account for bidirectional distances

    # Calculate all-pairs shortest paths
    shortest_paths = dict(nx.all_pairs_dijkstra_path_length(G))

    # Create a DataFrame with cumulative distances
    nodes = sorted(G.nodes)
    distance_matrix = pd.DataFrame(index=nodes, columns=nodes)

    for source in nodes:
        for target in nodes:
            if source == target:
                distance_matrix.at[source, target] = 0
            else:
                distance_matrix.at[source, target] = shortest_paths[source][target]

    return distance_matrix

# Example usage:
# Assuming 'path/to/dataset-3.csv' is the path to your dataset-3.csv file
file_path = 'Datasets/dataset-3.csv'
distance_matrix_result = calculate_distance_matrix(file_path)
print(distance_matrix_result)

"""### Question 2

#### We have to use here car_matrix created in question 1 in python_task1
"""

def generate_car_matrix(file_path):
    # Load the CSV file into a DataFrame
    df = pd.read_csv(file_path)

    # Pivot the DataFrame to create a matrix with id_1 as index, id_2 as columns, and car as values
    car_matrix = df.pivot(index='id_1', columns='id_2', values='car')

    # Fill NaN values with 0
    car_matrix = car_matrix.fillna(0)

    # Set diagonal values to 0
    for index in car_matrix.index:
        car_matrix.at[index, index] = 0

    return car_matrix

# Example usage:
file_path = 'Datasets/dataset-1.csv'
result_matrix = generate_car_matrix(file_path)
print(result_matrix)



import pandas as pd
from itertools import combinations

def unroll_distance_matrix(result_matrix):
    # Get the column names (id_2 values) from the distance matrix
    id_columns = result_matrix.columns

    # Create an empty DataFrame to store the unrolled distances
    unrolled_distances = pd.DataFrame(columns=['id_start', 'id_end', 'distance'])

    # Iterate over all combinations of id_2 values
    for id_start, id_end in combinations(id_columns, 2):
        # Extract the distance value for the current combination
        distance_value = result_matrix.loc[id_start, id_end]

        # Append the combination and distance to the unrolled_distances DataFrame
        unrolled_distances = pd.concat([unrolled_distances, pd.DataFrame([[id_start, id_end, distance_value]], columns=['id_start', 'id_end', 'distance'])], ignore_index=True)

    return unrolled_distances

# Example usage:
# Assuming result_matrix is the DataFrame obtained from Question 1
result_unrolled = unroll_distance_matrix(result_matrix)
print(result_unrolled)

"""### Question 3"""

import pandas as pd

def find_ids_within_ten_percentage_threshold(df, reference_value):
    # Filter the DataFrame based on the reference value
    reference_df = df[df['id_start'] == reference_value]

    # Calculate the average distance for the reference value
    reference_avg_distance = reference_df['distance'].mean()

    # Calculate the threshold for 10% of the average distance
    threshold = 0.1 * reference_avg_distance

    # Filter the DataFrame based on the threshold
    filtered_df = df[(df['distance'] >= (reference_avg_distance - threshold)) &
                     (df['distance'] <= (reference_avg_distance + threshold))]

    # Get the unique values from the 'id_start' column and sort them
    result_ids = sorted(filtered_df['id_start'].unique())

    return result_ids

# Example usage:
# Assuming result_unrolled is the DataFrame obtained from unrolling the distance matrix
reference_value = 807  # Replace with the desired reference value
result_within_threshold = find_ids_within_ten_percentage_threshold(result_unrolled, reference_value)
print(result_within_threshold)

"""### Question 4"""

import pandas as pd

def calculate_toll_rate(get_type_count):
    # Define rate coefficients for each vehicle type
    rate_coefficients = {'moto': 0.8, 'car': 1.2, 'rv': 1.5, 'bus': 2.2, 'truck': 3.6}

    # Create new columns for each vehicle type and calculate toll rates
    for vehicle_type, rate_coefficient in rate_coefficients.items():
        get_type_count[vehicle_type] = get_type_count['distance'] * rate_coefficient

    return get_type_count

# Example usage:
# Assuming unrolled_distances_result is the DataFrame obtained from the previous question
result_with_toll_rates = calculate_toll_rate(unrolled_distances_result)
print(result_with_toll_rates)

"""### Question 5"""

import pandas as pd
from datetime import time

def calculate_time_based_toll_rates(input_dataframe):
    # Define time ranges and discount factors
    time_ranges = {
        'weekday_morning': (time(0, 0, 0), time(10, 0, 0)),
        'weekday_afternoon': (time(10, 0, 0), time(18, 0, 0)),
        'weekday_evening': (time(18, 0, 0), time(23, 59, 59)),
        'weekend': (time(0, 0, 0), time(23, 59, 59))
    }

    discount_factors = {
        'weekday_morning': 0.8,
        'weekday_afternoon': 1.2,
        'weekday_evening': 0.8,
        'weekend': 0.7
    }

    # Create new columns for start_day, start_time, end_day, and end_time
    input_dataframe['start_day'] = input_dataframe['startDay'].dt.day_name()
    input_dataframe['start_time'] = input_dataframe['startTime'].apply(lambda x: x.time())
    input_dataframe['end_day'] = input_dataframe['endDay'].dt.day_name()
    input_dataframe['end_time'] = input_dataframe['endTime'].apply(lambda x: x.time())

    # Modify values of vehicle columns based on time ranges and discount factors
    for time_range, (start_time, end_time) in time_ranges.items():
        mask = (
            (input_dataframe['start_time'] >= start_time) &
            (input_dataframe['start_time'] <= end_time)
        )

        # Apply discount factors based on weekdays/weekends
        if time_range == 'weekend':
            mask |= (input_dataframe['startDay'].dt.dayofweek >= 5)  # 5 and 6 represent Saturday and Sunday

        for vehicle_type in ['moto', 'car', 'rv', 'bus', 'truck']:
            input_dataframe.loc[mask, vehicle_type] *= discount_factors[time_range]

    return input_dataframe

# Example usage:
# Assuming result_within_threshold is the DataFrame obtained from the previous question
result_with_time_based_toll_rates = calculate_time_based_toll_rates(result_within_threshold)
print(result_with_time_based_toll_rates)
